/* == Введение ==
   Этот документ представляет собой скрипт для системы компьютерной алгебры
   Maxima [1], предназначенный для определения вида операторов дивергенции и
   ротора в произвольной криволинейной системе координат (причём, не обязательно
   ортогональной). Первоначально он был написан для того, чтобы с его помощью
   составить систему уравнений Максвелла для рупорной антенный в одной хитрой
   системе координат, но, возможно, когда-нибудь он пригодится кому-то ещё
   (особенно, если я переведу комментарии на английский).

   Для запуска используйте команду «File→Batch file...» в главном меню wxMaxima,
   либо воспользуйтесь командной строкой:

       $ maxima -b curvilinear-diffs.mac

   (c) Павел Кретов, 2015.
   Свободно распространяется под лицензией Apache 2.0.

   === Исходные данные ===
   Прежде всего, нам необходимо задать размерность пространства (считаются
   только чисто пространственные координаты). Маловероятно, что кому-нибудь
   когда-нибудь понадобится значение, отличное от трёх, просто неприятно
   видеть в коде магические константы. */
N: 3 $

/* Затем нужно посчитать, как выражаются старые координаты через новые и
   наоборот. Теоретически, достаточно либо одного, либо другого, а недостающие
   выражения можно было бы заставить Максиму вывести самостоятельно, но скорее
   всего это не сработает для достаточно сложных уравнений. Это самое важное из
   условий, от него отталкивается весь дальнейший код.

   Кроме того, заметьте, что переменные называются не x и y, а xs и ys — это
   сделано специально, так как в противном случае нельзя было бы свободно
   использовать x[i] и y[i] как свободные переменные. */
xs: [ y[1], y[3]*y[2],  y[3] ] $
ys: [ x[1], x[2]/x[3], x[3] ] $

/* Кроме того, нас в данной конкретной задаче интересует только половина
   пространства (та, в которой находится рупор антенны), поэтому лучше всего
   сразу укажем Максиме на это и избавимся таким образом от знаков модуля,
   всплывающих в конечных формулах. */
assume(y[3] >= 0);

/* Также необходимо задать метрический тензор исходной системы координат, то
   есть той системы, в которой используются координаты x[i]. В данном случае
   в качестве исходной системы выступают декартовы ортонормированные координаты,
   метрический тензор которых равен символу Кронекера. */
g[i,j] := kron_delta(i, j);

/* Так как Максима выдаёт результаты в достаточно избыточной форме, для
   дальнейшей работы с ними вручную их неплохо бы упростить. Для этого к ним
   применяется указанная ниже функция упрощения. Это позволит сэкономить
   несколько рутинных преобразований и лишний раз избежать ошибки. К сожалению,
   процедура упрощения не универсальна и должна подбираться эмпирически. */
simplification(expr) := expand(trigsimp(expr)) $

/* === Вспомогательные конструкции ===
   Вообще в Максиме есть почти всё, что нужно для нормальной жизни. Но, вот,
   к сожалению, простого символа Леви-Чивита в ней нет, а определённый в пакете
   itensor, нам совершенно не подходит: он слишком навороченный. Напишем свой
   велосипед. */
Levi[i,j,k] := block(p:[i,j,k], if false then false
                   elseif p=[1,2,3] or p=[2,3,1] or p=[3,1,2] then  1
                   elseif p=[3,2,1] or p=[2,1,3] or p=[1,3,2] then -1
	           else 0) $

/* Кроме того, выполнение преобразований по тензорным формулам требует многих
   вложенных операций суммирования. Стандарная функция sum, вложенная несколько
   раз подряд, выглядит очень некрасиво и читается с трудом. Поэтому было решено
   написать собственную, более удобную функцию для суммирования, принимающую
   несколько индексов за раз в виде списка.

   Но к сожалению, не удалось заставить её работать, как надо. Она пока что
   просто побудет тут до тех пор, пока я не исправлю это. В скрипте она не
   используется. Смотрите http://stackoverflow.com/questions/31566284, если
   вам интересна суть проблемы. */
nsum(indexes, expr) :=
    if indexes = []
    then expr
    else nsum(rest(indexes), apply('sum, ['expr, first(indexes), 1, N])) $

/* === Собственно расчёт ===
   Приступим-с. Прежде всего посчитаем матрицы перехода из старой системы в
   новую и наоборот. Используем для этого общеизвестные формулы. */
S[i,j] := diff(xs[i], y[j]) $
T[i,j] := diff(ys[i], x[j]) $

/* Коэффициенты матрицы T являются функциями от старых координат, поэтому нам
   нужно записать их через координаты y[i]. Для этого подставим в выражения для
   коэффициентов вместо x[i] их выражение через y[i]. */
substXtoY: makelist(x[i] = xs[i], i, 1, N) $
TY[i,j] := subst(substXtoY, T[i,j]) $

/* На всякий случай проверим, что матрицы перехода получились взаимно обратными.
   Лишняя проверка позволит вовремя выявить ошибку пользователя, если он
   неправильно задал исходные значения xs и ys. */
Smatrix: genmatrix(S, N, N) $
TYmatrix: genmatrix(TY, N, N) $
(print("IMPORTANT: The following expression must equal to identity matrix"),
 display('(S . T) = simplification(Smatrix . TYmatrix))) $

/* Посчитаем метрический тензор новой системы координат. Он нам будет очень
   сильно нужен, так как от него зависит вид ковариантной производной. Кроме
   того, определитель матрицы метрического тензора входит в выражение для
   тензора объёма. */
G[i,j] := sum(sum( S[k,i]*S[m,j]*g[k,m], k, 1, N), m, 1, N) $
Gmatrix: genmatrix(G, N, N) $

/* Определим символы Кристоффеля, воспользовавшись готовой формулой из
   методички [2]. */
K[k,i,j] := sum(TY[k,q] * diff(S[q,j], y[i]), q, 1, N) $

/* Определим матрицу тензора объёма. Заметим, что здесь используется не
   обычная функция det, а newdet. Это сделано для того, чтобы выражение для
   детерминанта сразу расписалось на произведения и в итоговом результате
   не маячил полуупрощённый определитель. */
W[i,j,k] := 1/sqrt(newdet(Gmatrix)) * Levi[i,j,k] $

/* Определим оператор дивергенции. */
div(f) := sum(('diff(f[i], y[i]) + sum(K[i,i,j] * f[j], j, 1, N)), i, 1, N) $

rot2[i](f) := nsum( [r,j,k,q],
  G[r,i]*G[q,j]*w[i,j,k]*('diff(f[k], y[q]) + sum(K[k,q,m]*f[m], m, 1, N))) $

/* И ротор. К сожалению, функция nsum пока не работает, поэтому запись этой
   формулы будет очень некрасивой. Зато работает. */
rot[i](f) := sum(sum(sum(sum(
    G[r,i]*G[q,j]*W[i,j,k]*('diff(f[k], y[q]) + sum(K[k,q,m]*f[m], m, 1, N)),
        r, 1, N),
	j, 1, N),
	k, 1, N),
	q, 1, N) $

/* === Печать результатов ===
   Сначала выведем в цикле все найденные символы Кристоффеля. Многие из них,
   скорее всего, окажутся равными нулю, но в этом нет ничего страшного.
   В Максиме не нашлось подходящей функции для отображения трёхмерного массива,
   поэтому пришлось прибегнуть к итерации. */
for k: 1 thru N do
for i: 1 thru N do
for j: 1 thru N do display('K[k,i,j] = simplification(K[k,i,j])) $

/* Выведем упрощённые выражения для дивергенции и компонентов ротора. */
(display('div(f) = simplification(div(f))),
 for i: 1 thru N do
 display('rot[i](f) = simplification(rot[i](f)))) $

/* Самое время теперь убедиться, не нашли ли мы полную ерунду. Для этого
   возьмём дивергенцию от ротора и проверим, равна ли она нулю. Если нет,
   то всё было напрасно.

   Как оказалось, в Максиме нельзя просто взять и написать что-то вроде
   такого:
       (%i1) r[i] := rot[i](f) $
       (%i2) div(r);
   От этого она, почему-то, намертво зависает. Поэтому извернёмся и предвычислим
   значение ротора в отдельный список. */
block(
 testRotor: makelist(rot[i](f), i, 1, N),
 print("IMPORTANT! The following value must be zero."),
 display('(div(rot(f))) = ev(div(testRotor), nouns))) $